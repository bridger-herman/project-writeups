<article>
  <h1>Multi-Agent Motion Planning</h1>
  <h2>Description</h2>
  <p>
    Motion planning for agents in a virtual world
  </p>

  <h2>Features</h2>
  <ul>
    <li>Realtime, 3D rendering</li>
    <li>3D user controlled camera</li>
    <li>Realtime user interaction with system</li>
    <li>Probabilistic road map (PRM)</li>
    <li>Global navigation with A* Search</li>
    <li>Boids flocking simulation</li>
    <li>3D scenes</li>
    <li>Path smoothing</li>
  </ul>

  <h2>Challenges</h2>
  <p>
    The largest challenges in this project included creating the A* search
    algorithm, and tuning the parameters to make Boids look good. An additional
    challenge was figuring out if navigation should be done on a flock level, or
    on an individual agent level. Since each agent plans for itself, it's
    possible that the planning graphs for agents in the flock will differ,
    resulting in a badly behaving simulation where the agents move through
    obstacles. See Figure 12 at the end of the document for an example of this.
  </p>

  <h2>Controls</h2>
  <ul>
    <li><strong>WASD/Mouse:</strong> Camera control</li>
    <li><strong>g:</strong> Start/stop flock motion</li>
    <li><strong>h:</strong> Hide/show planning graphs for agents</li>
    <li><strong>r:</strong> Reset the simulation (need to press
        <strong>g</strong> again)</li>
    <li><strong>1-4:</strong> Select which flock force to adjust</li>
    <li><strong>z/x:</strong> Decrease/increase selected flock force</li>
  </ul>

  <h2>Implementation Details</h2>
  <h3>Overview</h3>
    <h4>Setup</h4>
      When the program is first run, the following steps occur:
      <ol>
        <li>Generate scene meshes (ground plane and obstacles)</li>
        <li>Create map with obstacles</li>
        <li>Initialize PRM from map</li>
        <li>Initialize flock and send planning graph to all agents</li>
        <li>Path-plan using A* or UCS</li>
      </ol>
    <h4>At each timestep</h4>
      At each timestep while the program is running, the following steps occur:
      <ol>
        <li>Update agent forces (goal-seeking and collision-avoidance)</li>
        <li>Update agent accelerations, velocities, and positions</li>
        <li>Determine all agents' next incremental goal</li>
        <li>Calculate new flock centroid based on agents' positions</li>
        <li>Update flock forces (Cohesive, Alignment, Separation)</li>
        <li>Render scene</li>
      </ol>

  <h3>Graph</h3>
  <p>
    Graphs are represented as a list of nodes, each with a location, a list of
    nodes that they are connected to, and the associated costs for each node.
    The graph handles all adding and removing of nodes, and connecting the nodes
    within the graph in a manner that does not intersect any obstacles. The
    graph uses the C-Space obstacles (See Figure 1) to calculate potential
    collisions.
  </p>

  <figure>
    <img src="./assets/project-planning/c_space.png" alt="Configuration
    space for a boid and obstacle">
    <figcaption>Configuration space for a boid and obstacle</figcaption>
  </figure>

  <h3>Probabilistic Road Map (PRM)</h3>
  <p>
    The PRM generates random locations within the dimensions of the map it is
    given, and populates a new graph with nodes at those locations. Every time
    the map is reset (when the user presses <strong>r</strong>), a new PRM is
    generated.
  </p>

  <h3>A* Search</h3>
  <p>
    A* search takes the graph generated by the PRM and returns a path from the
    start to the goal of a particular agent. The heuristic used by the
    algorithm is the straight-line distance from the current node to the goal
    node. This is an admissable heuristic because straight-line distance is
    always the shortest possible path between any two points.
  </p>

  <p>
    Compared with Uniform Cost Search (UCS), A* is much faster (see Figure 2).
    However, A* seemed to perform slightly worse from a path-length perspective,
    as shown in Figure 3. Data were obtained using a ten trials of a PRM graph
    with 125 nodes.
  </p>

  <ul class='tiled-list'>
    <li>
      <figure>
        <img src="./assets/project-planning/astar_ucs_time.png" alt="A Star
        takes less time than UCS">
        <figcaption>Average time for A* and UCS</figcaption>
      </figure>
    </li>
    <li>
      <figure>
        <img src="./assets/project-planning/astar_ucs_steps.png" alt="A Star
        has more steps than UCS">
        <figcaption>Average path length for A* and UCS</figcaption>
      </figure>
    </li>
  </ul>

  <h3>Boids</h3>
  <p>
    The Boids algorithm for multi-agent interactions is used in this project.
    Each Boid is a scaled, oriented sphere (shown in Figure 4). The orientation
    of each Boid follows the direction of its velocity, to allow for more
    realistic motion. In this particular implementation, there are five forces
    acting on each Boid agent:
  </p>

  <p>
    <strong>Cohesive:</strong> Seek the centroid of the flock. The vector
    betwee the flock centroid and the Boid's current location is calculated, and
    that directly becomes the cohesive force.
  </p>
  <p>
    <strong>Separation:</strong> Go away from closest neighbors. Sometimes this
    force resulted in the flock being squashed into a line, so an additional
    component was added that constrains the flock's stretch in any particular
    direction.
  </p>
  <p>
    <strong>Alignment:</strong> Try to stay aligned with closest neighbors
    using velocity. Currently just uses the average velocity of the entire
    flock, and it seems to work fine.
  </p>
  <p>
    <strong>Goal:</strong> Try to go towards next incremental goal
    (furthest visible node). At each timestep, each Boid tries to find the
    node along its planned path that is farthest from its current position, and
    closest to the goal (using Path Smoothing).
  </p>
  <p>
    <strong>Obstacle-avoiding:</strong> Try to avoid every obstacle. The
    distance from the center of every obstacle to the Boid's current position is
    calculated, which directly becomes the force acting on the Boid.
  </p>

  <figure>
    <img src="./assets/project-planning/single_boid.png" alt="A singular
    Boid object">
    <figcaption>A singular Boid object</figcaption>
  </figure>

  <h3>Path Smoothing</h3>
  <p>
    Path smoothing was implemented to improve the performance of the agents.
    Before path-smoothing, the agents relied on traversing their planning graph
    in a sequential order, which caused many agents to circle back if they
    missed a goal. The path smoothing approach, shown in Figure 5, avoids this
    problem entirely by allowing the agent to go to the farthest-away node it
    can see.
  </p>

  <figure>
    <img src="./assets/project-planning/path_smooth.png" alt="Path smoothing">
    <figcaption>Diagram of path smoothing, showing the global path plan and the
      next node that the agent will try to go to (with and without path
      smoothing).
    </figcaption>
  </figure>


  <h2>Code</h2>
  <p>
    Code from this project can be found in <a
    href="https://github.umn.edu/herma582/5611-hw3">this GitHub repo</a>.

    The code is written in C++ and makes use of the following external libraries:
    <ul>
      <li><strong>OpenGL 3.3 API:</strong> Graphics</li>
      <li><strong>SDL2:</strong> Window management</li>
      <li><strong>GLM:</strong> Matrix/Vector mathematics</li>
      <li><strong>stb_image:</strong> Loading image textures</li>
    </ul>
  </p>

  <h2>Videos</h2>
  <ul class="tiled-list">
    <li>
      <iframe width="560" height="315"
      src="https://www.youtube.com/embed/ov0odB9IEIQ?rel=0" frameborder="0"
      allow="encrypted-media" allowfullscreen></iframe>
      <figcaption>Dance contest</figcaption>
    </li>
    <li>
      <iframe width="560" height="315"
      src="https://www.youtube.com/embed/X6eHvDLMp5c?rel=0" frameborder="0"
      allow="encrypted-media" allowfullscreen></iframe>
      <figcaption>Boids scenario 1</figcaption>
    </li>
    <li>
      <iframe width="560" height="315"
      src="https://www.youtube.com/embed/RD5uME0zYGE?rel=0" frameborder="0"
      allow="encrypted-media" allowfullscreen></iframe>
      <figcaption>Boids scenario 2</figcaption>
    </li>
    <li>
      <iframe width="560" height="315"
      src="https://www.youtube.com/embed/ckNdFpvSzhA?rel=0" frameborder="0"
      allow="encrypted-media" allowfullscreen></iframe>
      <figcaption>Situation where Boids breaks</figcaption>
    </li>
    <li>
      <iframe width="560" height="315"
      src="https://www.youtube.com/embed/FJMk_ZIrHBQ?rel=0" frameborder="0"
      allow="encrypted-media" allowfullscreen></iframe>
      <figcaption>Check-in</figcaption>
    </li>
  </ul>

  <h2>Images</h2>
  <figure>
    <img src="./assets/project-planning/agents_navigating.png" alt="100 Boids navigating">
    <figcaption>100 Boids navigating through an environment</figcaption>
  </figure>
  <figure>
    <img src="./assets/project-planning/wrong_path.png" alt="Different paths">
    <figcaption>Sometimes agents choose different paths based on their start
    locations</figcaption>
  </figure>
  <figure>
    <img src="./assets/project-planning/check-in.png" alt="Check-in image">
    <figcaption>Basic path planning using PRM and A*</figcaption>
  </figure>

</article>
<!-- <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script> -->
